# Dynamic Programming
하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 방법
<br>
<br>

---
## 1. 포도주 시식 (baekjoon 2156) 
<br>

### 문제
포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다. <br>
**연속으로 놓여 있는 3잔을 모두 마실 수는 없다.** <br>
n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각각의 포도주의 양이 주어졌을 때, **최대로 마실 수 있는 포도주의 양**을 출력해라. <br>
<br>
### 풀이
최대값을 구하는 문제이고 연속으로 3잔을 마실 수 없다고 했으니 작은 단위로 끊어서 생각하면 될 것같아서 dp로 풀었다.


**단계별로 생각하자** <br>

가능한 경우 : <br>
1. i번째 포도주를 마시는 경우<br>
    * i-2번째 포도주는 마심, i-1번째는 안마심 : ```d[i-2] + arr[i]```
    * i-1번째 포도주를 마심, i-2번째는 안마심 : ```d[i-3] + arr[i-1] + arr[i]```
2. i번째 포도주를 마시지 않는 경우 : ```d[i-1]```
<br>

* d[0], d[1], d[2] 까지는 따로 처리!! (index error 남)

<br>
<br>

---
## 2. 그냥 평범한 배낭 (baekjoon 12865) 
<br>

### 문제
N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가진다. 배낭엔 최대 K만큼의 무게를 넣을 수 있다. 배낭에 넣을 수 있는 물건들의 **가치의 최댓값**을 알려주자. <br>
<br>
### 풀이

**ver 1 )** 28104KB, 7608ms <br>

dp로 유명한 문제,,,라서 dp로 품 ( + 최댓값 구하기 문제라)<br>
1. 물건을 넣을 때의 가치를 담아둘 (n+1)*(k+1) 배열 생성 
<br> * (열 : 가능한 용량/아무것도 안담고, 무게가 없을 때를 위해 +1)
2. i번째 물건의 무게 < 열(가능한 용량) 경우 : <br> 이 물건이 들어갔을 때와 들어가지 않았을 때의 가치 비교<br>
    * ``` max(d[i-1][j-w[i-1]]+v[i-1],d[i-1][j])```
3. i번째 물건의 무게 > 열(가능한 용량)  경우:<br> 그 전거 그대로 <br>

-> 문제 시간 넘 오래걸림
<br>
<br>
**ver 2 )** 33688KB, 3708ms <br>

최대 무게가 정해져 있기 때문에 물건 무게를 중심으로 두고 최대 무게 ~ 가능한 무게까지  가치를 더하기 (누적 느낌~~~)

1. 누적으로 담기 때문에 k+1인 일차원 배열(d) 생성
2. 최대 무게 k 부터 i번째 물건 무게인 w 까지 내려가면서 가치 비교 <br>
: 담을 때  ``` max(d[j], d[j-w] + v) ```로 큰 걸 계속 업데이트 <br>

-> 이것도 시간 오래 걸림
<br>
<br>
**ver 3 )** 40684KB, 816ms <br>

ver 2가 물건의 수와 상관없이 최대 무게 K에서 물건의 무게까지 루프를 돌아서 시간이 오래걸림
-> **dic으로 풀기**

1. { 물건들의 무게 합 : 물건들의 가치 합 }으로 만들 dictionary d 생성
2. d를 돌면서 ```(d안의 무게 + 들어올 무게) <= k and (d안의 가치 + 들어올 가치) > d.get(d안의 무게 + 들어올 무게,0)``` 이면 ```tmp[d안의 무게 + 들어올 무게] =  d안의 가치 + 들어올 가치``` 로 확인 
<br> * d.get(a,0) >> d[a]가 없으면 0 반환<br> * 루프를 돌 때 dictionary를 업데이트하면 에러 >> tmp 딕셔너리를 만들어서 루프끝나면 update로 d에 갱신




